- First stab at memory mapped FDCAN SRAM
  - `Into<U>` is a neat little trait: auto converstion based on expected return type
  - Completed the standard filter memory map
    - Probably a bit too over-complicated since it's based on the full `stm32-rs` codebase
    - Target for a later refactor
  - Was wondering why it wasn't working at first: modifying the filter didn't seem to do ... anything?
    - Turns out FDCAN SRAM is only enabled once the CAN clock is enabled on `AHB1`
  - Something to keep in mind: SRAM is _only addressable in words_; byte addressing doesn't work (writes the same byte 4x)

- Man, Rust macros are _powerful_
  - And that's just talking about `macro_rules!`, not even the procedural macros!
  - Scoping/exporting is a bit of a bear though :bear: